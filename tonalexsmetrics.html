<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>Event-Driven 44-Metric Audio Analyzer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body,
        html {
            margin: 0;
            padding: 0
        }

        table {
            width: 95%;
            border-collapse: collapse
        }

        th,
        td {
            border: 1px solid #000;
            padding: 8px;
            text-align: left
        }
    </style>
</head>

<body><label for="audioFile">Audio File:</label><input type="file" id="audioFile" accept="audio/*" title="Upload audio">
    <table id="audioMetricsTable">
        <tr>
            <th>Metric</th>
            <th>Value</th>
            <th>threshld value</th>
            <th>formula</th>
            <th>tooltip</th>
        </tr>
    </table>
    <script>document.addEventListener("DOMContentLoaded", function () { document.getElementById("audioFile").addEventListener("change", function (e) { const t = e.target.files[0]; if (!t) return; const n = new (AudioContext || webkitAudioContext), o = new FileReader; o.onload = function (e) { n.decodeAudioData(e.target.result, function (e) { processAudio(e, t) }) }; o.readAsArrayBuffer(t) }) }); function processAudio(e, t) { const n = e.sampleRate, o = e.numberOfChannels, a = 16, r = e.duration, i = t.size, c = t.type, l = "PCM", m = n * a * o / 1e3, d = e.getChannelData(0), p = []; const s = [function () { p.push(["1. Duration", r.toFixed(2) + " s"]) }, function () { p.push(["2. Sample Rate", n + " Hz"]) }, function () { p.push(["3. Number of Channels", o]) }, function () { p.push(["4. Bit Depth", a + " bits"]) }, function () { p.push(["5. File Size", i + " bytes"]) }, function () { p.push(["6. Audio Format", c]) }, function () { p.push(["7. Peak Amplitude", getMaxValueIter(d).toFixed(4)]) }, function () { p.push(["8. RMS Amplitude", getRMSAmplitude(d).toFixed(4)]) }, function () { p.push(["9. Zero Crossings", calculateZeroCrossings(d)]) }, function () { p.push(["10. Codec", l]) }, function () { p.push(["11. Bitrate", m.toFixed(2) + " kbps"]) }, function () { p.push(["12. Spectral Centroid", calculateSpectralCentroid(d, n).toFixed(4)]) }, function () { p.push(["13. Spectral Flatness", calculateSpectralFlatness(d).toFixed(4)]) }, function () { p.push(["14. Spectral Bandwidth", calculateSpectralBandwidth(d, n).toFixed(4)]) }, function () { p.push(["15. Spectral Roll-Off", calculateSpectralRollOff(d, n).toFixed(4)]) }, function () { p.push(["16. Total Energy", calculateTotalEnergy(d).toFixed(4)]) }, function () { p.push(["17. Mean Energy", calculateMeanEnergy(d).toFixed(4)]) }, function () { p.push(["18. Dynamic Range", calculateDynamicRange(d).toFixed(4)]) }, function () { p.push(["19. Crest Factor", calculateCrestFactor(d).toFixed(4)]) }, function () { p.push(["20. Spectral Energy", calculateSpectralEnergy(d).toFixed(4)]) }, function () { p.push(["21. Spectral Flux", calculateSpectralFlux(d).toFixed(4)]) }, function () { p.push(["22. Spectral Entropy", calculateSpectralEntropy(d).toFixed(4)]) }, function () { p.push(["23. Attack Time", (1e3 * calculateAttackTime(d, n)).toFixed(2) + " ms"]) }, function () { p.push(["24. Decay Time", (1e3 * calculateDecayTime(d, n)).toFixed(2) + " ms"]) }, function () { p.push(["25. Sustain Level", calculateSustainLevel(d).toFixed(4)]) }, function () { p.push(["26. Release Time", (1e3 * calculateReleaseTime(d, n)).toFixed(2) + " ms"]) }, function () { p.push(["27. Spectral Slope", calculateSpectralSlope(d, n).toFixed(4)]) }, function () { p.push(["28. Inharmonicity", calculateInharmonicity(d).toFixed(4)]) }, function () { p.push(["29. Harmonic Ratio", calculateHarmonicRatio(d).toFixed(4)]) }, function () { p.push(["30. Transient Energy", calculateTransientEnergy(d).toFixed(4)]) }, function () { p.push(["31. Sustain Energy", calculateSustainEnergy(d).toFixed(4)]) }, function () { p.push(["32. Normalized Energy", calculateNormalizedEnergy(d).toFixed(4)]) }, function () { p.push(["33. Energy Envelope Variance", calculateEnergyEnvelopeVariance(d).toFixed(4)]) }, function () { p.push(["34. Temporal Centroid", calculateTemporalCentroid(d, n).toFixed(4)]) }, function () { p.push(["35. Low Energy Ratio", calculateLowEnergyRatio(d).toFixed(4)]) }, function () { p.push(["36. Spectral Kurtosis", calculateSpectralKurtosis(d).toFixed(4)]) }, function () { p.push(["37. Spectral Skewness", calculateSpectralSkewness(d).toFixed(4)]) }, function () { p.push(["38. Harmonic Distortion", calculateHarmonicDistortion(d).toFixed(4)]) }, function () { p.push(["39. Spectral Spread", calculateSpectralSpread(d, n).toFixed(4)]) }, function () { p.push(["40. Temporal Flatness", calculateTemporalFlatness(d).toFixed(4)]) }, function () { p.push(["41. Temporal Variance", calculateTemporalVariance(d).toFixed(4)]) }, function () { p.push(["42. Transient Energy Ratio", calculateTransientEnergyRatio(d).toFixed(4)]) }, function () { p.push(["43. Spectral Contrast", calculateSpectralContrast(d).toFixed(4)]) }, function () { p.push(["44. Fundamental Frequency", calculateFundamentalFrequency(d).toFixed(4)]) }]; let f = 0; function g() { if (f >= s.length) { updateTable(p); return } setTimeout(function () { s[f](); f++; g() }, 0) } g() } function updateTable(e) { const t = document.getElementById("audioMetricsTable"); t.innerHTML = "<tr><th>Metric</th><th>Value</th></tr>"; for (let n = 0; n < e.length; n++) { t.innerHTML += "<tr><td>" + e[n][0] + "</td><td>" + e[n][1] + "</td></tr>" } } function getMaxValueIter(e) { let t = -1 / 0; for (let n = 0; n < e.length; n++) { e[n] > t && (t = e[n]) } return t } function getRMSAmplitude(e) { let t = 0; for (let n = 0; n < e.length; n++) { t += e[n] * e[n] } return Math.sqrt(t / e.length) } function calculateZeroCrossings(e) { let t = 0; for (let n = 1; n < e.length; n++) { (e[n - 1] > 0 && e[n] < 0 || e[n - 1] < 0 && e[n] > 0) && t++ } return t } function calculateSpectralCentroid(e, t) { let n = 0, o = 0; for (let a = 0; a < e.length; a++) { n += a * Math.abs(e[a]); o += Math.abs(e[a]) } return 0 === o ? 0 : n / o * (t / e.length) } function calculateSpectralFlatness(e) { let t = 1, n = 0; for (let o = 0; o < e.length; o++) { t *= Math.abs(e[o]); n += Math.abs(e[o]) } t = Math.pow(t, 1 / e.length); n /= e.length; return 0 === n ? 0 : t / n } function calculateSpectralBandwidth(e, t) { const n = calculateSpectralCentroid(e, t); let o = 0, a = 0; for (let r = 0; r < e.length; r++) { o += Math.pow(r * (t / e.length) - n, 2) * Math.abs(e[r]); a += Math.abs(e[r]) } return 0 === a ? 0 : Math.sqrt(o / a) } function calculateSpectralRollOff(e, t, n = .85) { let o = 0; const a = e.reduce((e, t) => e + Math.abs(t), 0); for (let r = 0; r < e.length; r++) { if ((o += Math.abs(e[r])) >= n * a) return r * (t / e.length) } return 0 } function calculateTotalEnergy(e) { let t = 0; for (let n = 0; n < e.length; n++) { t += e[n] * e[n] } return t } function calculateMeanEnergy(e) { return calculateTotalEnergy(e) / e.length } function calculateDynamicRange(e) { let t = 0, n = 1 / 0; for (let o = 0; o < e.length; o++) { const a = Math.abs(e[o]); a > t && (t = a); a < n && (n = a) } return 20 * Math.log10(t / (n || 1)) } function calculateCrestFactor(e) { const t = getMaxValueIter(e), n = getRMSAmplitude(e); return t / (n || 1) } function calculateSpectralEnergy(e) { let t = 0; for (let n = 0; n < e.length; n++) { t += e[n] * e[n] } return t } function calculateSpectralFlux(e) { let t = 0; for (let n = 1; n < e.length; n++) { t += Math.abs(e[n] - e[n - 1]) } return t / e.length } function calculateSpectralEntropy(e) { const t = calculateSpectralEnergy(e); let n = 0; for (let o = 0; o < e.length; o++) { const a = e[o] * e[o] / t; a > 0 && (n -= a * Math.log2(a)) } return n } function calculateAttackTime(e, t) { const n = .1 * getMaxValueIter(e.map(e => Math.abs(e))); for (let o = 0; o < e.length; o++) { if (Math.abs(e[o]) >= n) return o / t } return 0 } function calculateDecayTime(e, t) { const n = .1 * getMaxValueIter(e.map(e => Math.abs(e))); for (let o = e.length - 1; o >= 0; o--) { if (Math.abs(e[o]) >= n) return (e.length - o) / t } return 0 } function calculateSustainLevel(e) { const t = getMaxValueIter(e.map(e => Math.abs(e))), n = e.filter(e => Math.abs(e) >= .7 * t); return n.length / e.length } function calculateReleaseTime(e, t) { const n = .05 * getMaxValueIter(e.map(e => Math.abs(e))); for (let o = e.length - 1; o >= 0; o--) { if (Math.abs(e[o]) <= n) return (e.length - 1 - o) / t } return 0 } function calculateSpectralSlope(e, t) { let n = 0, o = 0, a = 0, r = 0; const i = e.length; for (let c = 0; c < i; c++) { const l = c * (t / i), m = Math.abs(e[c]); n += l * m, o += l, a += m, r += l * l } return (i * n - o * a) / (i * r - o * o) } function calculateInharmonicity(e) { return 0 } function calculateHarmonicRatio(e) { return 0 } function calculateTransientEnergy(e) { const t = calculateTotalEnergy(e); let n = 0; for (let o = 1; o < e.length; o++) { n += Math.pow(e[o] - e[o - 1], 2) } return n / t } function calculateSustainEnergy(e) { const t = calculateTotalEnergy(e); let n = 0; for (let o = 1; o < e.length; o++) { n += e[o] * e[o] } return n / t } function calculateNormalizedEnergy(e) { return calculateTotalEnergy(e) / e.length } function calculateEnergyEnvelopeVariance(e) { const t = calculateMeanEnergy(e); let n = 0; for (let o = 0; o < e.length; o++) { n += Math.pow(e[o] - t, 2) } return n / e.length } function calculateTemporalCentroid(e, t) { let n = 0, o = 0; for (let a = 0; a < e.length; a++) { const r = a / t, l = Math.abs(e[a]); n += r * l; o += l } return 0 === o ? 0 : n / o } function calculateLowEnergyRatio(e) { const t = calculateMeanEnergy(e); let n = 0; for (let o = 0; o < e.length; o++) { Math.pow(e[o], 2) < t && n++ } return n / e.length } function calculateSpectralKurtosis(e) { const t = e.reduce((e, t) => e + t, 0) / e.length; let n = 0, o = 0; for (let a = 0; a < e.length; a++) { n += Math.pow(e[a] - t, 2), o += Math.pow(e[a] - t, 4) } return n /= e.length, o /= e.length, o / Math.pow(n, 2) } function calculateSpectralSkewness(e) { const t = e.reduce((e, t) => e + t, 0) / e.length; let n = 0, o = 0; for (let a = 0; a < e.length; a++) { n += Math.pow(e[a] - t, 2), o += Math.pow(e[a] - t, 3) } return n /= e.length, o /= e.length, o / Math.pow(n, 1.5) } function calculateHarmonicDistortion(e) { return 0 } function calculateSpectralSpread(e, t) { const n = calculateSpectralCentroid(e, t); let o = 0; for (let a = 0; a < e.length; a++) { const r = a * t / e.length; o += Math.pow(r - n, 2) * Math.abs(e[a]) } return Math.sqrt(o / e.length) } function calculateTemporalFlatness(e) { const t = e.length, n = Math.exp(e.reduce((e, t) => e + Math.log(Math.abs(t) + 1e-10), 0) / t), o = e.reduce((e, t) => e + Math.abs(t), 0) / t; return n / o } function calculateTemporalVariance(e) { const t = e.reduce((e, t) => e + t, 0) / e.length; let n = 0; for (let o = 0; o < e.length; o++) { n += Math.pow(e[o] - t, 2) } return n / e.length } function calculateTransientEnergyRatio(e) { const t = calculateEnergyEnvelope(e), n = t.reduce((e, t) => e + t, 0); let o = 0; for (let a = 1; a < t.length; a++) { t[a] > t[a - 1] && (o += t[a]) } return o / n } function calculateEnergyEnvelope(e) { return e.map(e => Math.abs(e)) } function calculateSpectralContrast(e) { return 0 } function calculateFundamentalFrequency(e) { return 0 }</script>
</body>

</html>